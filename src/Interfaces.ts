/**
 * @license MIT
 */

import { LinkMatcherOptions } from './Interfaces';
import { LinkMatcherHandler, LinkMatcherValidationCallback } from './Types';
import {BufferSet} from './BufferSet';

export interface IBrowser {
  isNode: boolean;
  userAgent: string;
  platform: string;
  isFirefox: boolean;
  isMSIE: boolean;
  isMac: boolean;
  isIpad: boolean;
  isIphone: boolean;
  isMSWindows: boolean;
}

export interface ITerminal {
  element: HTMLElement;
  rowContainer: HTMLElement;
  selectionContainer: HTMLElement;
  charMeasure: ICharMeasure;
  textarea: HTMLTextAreaElement;
  ybase: number; // Todo should be deleted from here, because it will be used from buffer. @parisk part
  ydisp: number; // Todo should be deleted from here, because it will be used from buffer. @parisk part
  lines: ICircularList<string>; // Todo should be moved to buffer at all!!! @parisk part
  rows: number;
  cols: number;
  diff: number; // todo should be calculated and moved to the buffer, but how!!!!!
  browser: IBrowser;
  writeBuffer: string[];
  children: HTMLElement[];
  cursorHidden: boolean; // todo seems should be moved to the buffer and restored after switching from alt buffer to normal buffer(and otherwise) => 1047, 47, 1049 in the InputHandler!!!!
  cursorState: number; // todo seems should be moved to the buffer  and restored after switching from alt buffer to normal buffer(and otherwise) => 1047, 47, 1049 in the InputHandler!!!!
  x: number;
  y: number;
  defAttr: number; // todo hmm... check maybe it should be moved to the buffer and restored after switching from alt buffer to normal buffer(and otherwise) => 1047, 47, 1049 in the InputHandler!!!!? We need to find testcases to check this stuff, maybe it's will fixes some bugs with background colors or so on.
  scrollback: number;
  // buffer and viewport @parisk changes. I need it.
  buffers: BufferSet; // This should be a `Buffer` class, but it would result in circular dependency
  // Todo we need think about it. Seems Alt buffer doesn't use scroll(in the xterm.js we uses ViewPort for alt screen, but I believe it's a mistake, which produces hard bugs.), so I'm not sure that we need scrollPort for alt buffer at all... But we exactly need it for normal buffer... Maybe this field should not be in the buffer and we need stay it in the ITerminal.
  viewport: any;

  /**
   * Emit the 'data' event and populate the given data.
   * @param data The data to populate in the event.
   */
  handler(data: string);
  on(event: string, callback: () => void);
  scrollDisp(disp: number, suppressScrollEvent: boolean);
  cancel(ev: Event, force?: boolean);
  log(text: string): void;
  emit(event: string, data: any);
  blankLine(cur: any, isWrapped: boolean); // todo cur should be some array
  // reset() and showCursor() @parisk changes. I need it.
  reset(): void;
  showCursor(): void;
  refresh(start: number, end: number);
}

export interface ISelectionManager {
  selectionText: string;
}

export interface ICharMeasure {
  width: number;
  height: number;
  measure(): void;
}

export interface ILinkifier {
  linkifyRow(rowIndex: number): void;
  attachHypertextLinkHandler(handler: LinkMatcherHandler): void;
  registerLinkMatcher(regex: RegExp, handler: LinkMatcherHandler, options?: LinkMatcherOptions): number;
  deregisterLinkMatcher(matcherId: number): boolean;
}

export interface ICircularList<T> {
  length: number;
  maxLength: number;

  forEach(callbackfn: (value: T, index: number, array: T[]) => void): void;
  get(index: number): T;
  set(index: number, value: T): void;
  push(value: T): void;
  pop(): T;
  splice(start: number, deleteCount: number, ...items: T[]): void;
  trimStart(count: number): void;
  trimEnd(count: number): void;
  shiftElements(start: number, count: number, offset: number): void;
}

export interface LinkMatcherOptions {
  /**
   * The index of the link from the regex.match(text) call. This defaults to 0
   * (for regular expressions without capture groups).
   */
  matchIndex?: number;
  /**
   * A callback that validates an individual link, returning true if valid and
   * false if invalid.
   */
  validationCallback?: LinkMatcherValidationCallback;
  /**
   * The priority of the link matcher, this defines the order in which the link
   * matcher is evaluated relative to others, from highest to lowest. The
   * default value is 0.
   */
  priority?: number;
}

/**
 * Handles actions generated by the parser.
 */
export interface IInputHandler {
  addChar(char: string, code: number): void;

  /** C0 BEL */ bell(): void;
  /** C0 LF */ lineFeed(): void;
  /** C0 CR */ carriageReturn(): void;
  /** C0 BS */ backspace(): void;
  /** C0 HT */ tab(): void;
  /** C0 SO */ shiftOut(): void;
  /** C0 SI */ shiftIn(): void;

  /** CSI @ */ insertChars(params?: number[]): void;
  /** CSI A */ cursorUp(params?: number[]): void;
  /** CSI B */ cursorDown(params?: number[]): void;
  /** CSI C */ cursorForward(params?: number[]): void;
  /** CSI D */ cursorBackward(params?: number[]): void;
  /** CSI E */ cursorNextLine(params?: number[]): void;
  /** CSI F */ cursorPrecedingLine(params?: number[]): void;
  /** CSI G */ cursorCharAbsolute(params?: number[]): void;
  /** CSI H */ cursorPosition(params?: number[]): void;
  /** CSI I */ cursorForwardTab(params?: number[]): void;
  /** CSI J */ eraseInDisplay(params?: number[]): void;
  /** CSI K */ eraseInLine(params?: number[]): void;
  /** CSI L */ insertLines(params?: number[]): void;
  /** CSI M */ deleteLines(params?: number[]): void;
  /** CSI P */ deleteChars(params?: number[]): void;
  /** CSI S */ scrollUp(params?: number[]): void;
  /** CSI T */ scrollDown(params?: number[]): void;
  /** CSI X */ eraseChars(params?: number[]): void;
  /** CSI Z */ cursorBackwardTab(params?: number[]): void;
  /** CSI ` */ charPosAbsolute(params?: number[]): void;
  /** CSI a */ HPositionRelative(params?: number[]): void;
  /** CSI b */ repeatPrecedingCharacter(params?: number[]): void;
  /** CSI c */ sendDeviceAttributes(params?: number[]): void;
  /** CSI d */ linePosAbsolute(params?: number[]): void;
  /** CSI e */ VPositionRelative(params?: number[]): void;
  /** CSI f */ HVPosition(params?: number[]): void;
  /** CSI g */ tabClear(params?: number[]): void;
  /** CSI h */ setMode(params?: number[]): void;
  /** CSI l */ resetMode(params?: number[]): void;
  /** CSI m */ charAttributes(params?: number[]): void;
  /** CSI n */ deviceStatus(params?: number[]): void;
  /** CSI p */ softReset(params?: number[]): void;
  /** CSI q */ setCursorStyle(params?: number[]): void;
  /** CSI r */ setScrollRegion(params?: number[]): void;
  /** CSI s */ saveCursor(params?: number[]): void;
  /** CSI u */ restoreCursor(params?: number[]): void;
}
